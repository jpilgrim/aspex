import {ProcessorState} from "InputProcessor";
import {InputSource} from "InputSource";
import {Block} from "Nodes";
import {Document} from "Nodes";
import {Element} from "Nodes";
import {ElementType} from "Nodes";
import {Inline} from "Nodes";
import {Paragraph} from "Nodes";


export public class ExtensionContext {

	@Final
	public indentLevel: int;

	@Final
	public currentElement: Element;

	@Final
	public processorState: ProcessorState;

	@Final
	public inputSource: InputSource;

	constructor(@Spec spec: ~i~this) {}

	public get line(): string {
		return this.inputSource.line;
	}

	public get restOfLine(): string {
		return this.inputSource.restOfLine;
	}
}

export public interface ~ElementProvider {
	/**
	 * Creates the element.
	 */
	createElement(context: ExtensionContext): Element

	/**
	 * Close element previously created with createElement. This method is only called if ctrlEnd returns not undefined.
	 */
	closeElement(element: Element, context: ExtensionContext)
}

/**
 * Defines how the end of an extension is detected by the lexer and parser.
 * 
 * Except for the CTRL end, the end of the extension is detected by the parser and
 * the characters signaling the end are not consumed by the extension. For 
 * extensions/elements ending with CTRL, the end is detected by the lexer and
 * the control sequence ending the element is consumed by the extension element (it 
 * becomes part of the CTRL sequence).
 */
@StringBased
export public enum ExtensionEndMarker {
	/**
	 * None end marker is used for blocks or paragraphs. The end of both
	 * element types is detected implicitly by the parser via a changed
	 * indentation level (block) or by empty lines or other elements ending
	 * a paragraph.
	 */
	NONE,
	/**
	 * Usually for inline elements, ends with an arbitrary sequence of characters
	 * starting with a control character.
	 * 
	 * The end of the extension is detected by the lexer.
	 */
	CTRL,
	/**
	 * Usually for line elements, ends with the end of line.
	 * 
	 * The end of the extension is detected by the lexer.
	 */
	EOL,
	/**
	 * Usually for inline elements, ends with a space (or EOL) character.
	 * 
	 * The end of the extension is detected by the lexer.
	 */
	SPACE
}

export public interface ~Extension extends ElementProvider {

	/**
	 * Name of extension.
	 */
	get name(): string

	/**
	 * True if extension can be referenced by name (followed by command suffix, ":" by default).
	 * E.g., if name is "INFO", if refByName is true, the extension is used via "INFO:".
	 */
	get refByName(): boolean

	/**
	 * Returns element type.
	 */
	get elementType(): ElementType

	/**
	 * Returns the end marker type, that is, how the lexer and parser detect the end
	 * of the extension region.
	 */
	get endMarker(): ExtensionEndMarker

	/**
	 * Control-character(s) which is used to identify whether ctrlMatch is called for further evaluation. 
	 * If ctrlStart is undefined or empty, the extension can only be referenced by name. The returned
	 * character must be of Categegory "OTHER".
	 */
	get ctrlStart(): string

	/**
	 * Called if ctrlStart is found by lexer. This method is called with current line (starting with ctrlStart).
	 * It returns the length of the match, if any, or 0 otherwise. If multiple extension
	 * match, the one with the longer match one is chosen. 
	 */
	matchCtrlStart(line: string): int

	/**
	 * Control-character(s) which is used to identify whether ctrlMatchEnd is called for further evaluation. 
	 * If ctrlEnd is undefined or empty, the extension can only be referenced by name or doesn't need an end.
	 * Note that only extensions are queried which have been started (and not yet ended).
	 */
	get ctrlEnd(): string

	/**
	 * Called if ctrlEnd is found by lexer. This method is called with current line (starting with ctrlEnd).
	 * It returns the length of the match, if any, or 0 otherwise. Only the last started (but not yet ended)
	 * extension is called. All inline extensions automatically end at end of line.
	 */
	matchCtrlEnd(line: string): int

}

/**
 * Default implementation of Extension.
 */
export public abstract class AbstractExtension implements Extension {

	/** Returns false by default. */
	@Override
	public get refByName(): boolean {
		return false;
	}

	/** Returns undefined by default, i.e., extension cannot be referenced by control sequence. */
	@Override
	public get ctrlStart(): string {
		return undefined;
	}

	/** Returns 0 by default. */
	@Override
	public matchCtrlStart(line: string): int {
		return 0;
	}

	/** Returns undefined by default, i.e., extension has no explicit end character. */
	@Override
	public get ctrlEnd(): string {
		return undefined;
	}

	/**
	 * Returns 0 by default. 
	 */
	@Override
	public matchCtrlEnd(line: string): int {
		return 0;
	}

	/**
	 * Does nothing by default.
	 */
	@Override
	public closeElement(element: Element, context: ExtensionContext) {
		// nothing by default
	}

}

export public class NamedBlockCommand extends AbstractExtension {

	@Override @Final
	public name: string;
	constructor(name: string) {
		this.name = name;
	}

	@Override
	public get refByName(): boolean {
		return true;
	}

	@Override
	public get elementType(): ElementType {
		return ElementType.BLOCK;
	}

	@Override
	public get endMarker(): ExtensionEndMarker {
		return ExtensionEndMarker.NONE;
	}

	/**
	 * Creates element with name and appends it to the parent element with given indentation.
	 */
	@Override
	public createElement(context: ExtensionContext): Element {
		return new Block(this.name, context.indentLevel + 1, context.currentElement);
	}

}

export public class InlineFormatting extends AbstractExtension {

	@Final
	ctrlChar: string;

	@Override
	@Final
	public name: string;

	constructor(ctrlChar: string, name: string) {
		this.ctrlChar = ctrlChar;
		this.name = name;
	}

	@Override
	public get elementType(): ElementType {
		return ElementType.INLINE;
	}

	@Override
	public get endMarker(): ExtensionEndMarker {
		return ExtensionEndMarker.CTRL;
	}

	@Override
	public get ctrlStart(): string {
		return this.ctrlChar;
	}

	@Override
	public get ctrlEnd(): string {
		return this.ctrlChar;
	}

	@Override
	public matchCtrlStart(line: string): int {
		if (line.startsWith(this.ctrlStart)) {
			return 1;
		}
		return 0;
	}

	@Override
	public matchCtrlEnd(line: string): int {
		return this.matchCtrlStart(line);
	}

	@Override
	public createElement(context: ExtensionContext): Element {
		return new Inline(this.name, context.indentLevel, context.currentElement);
	}
}

export public class DocumentHandler extends AbstractExtension {

	@Override
	public get name(): string {
		return "p";
	}

	@Override
	public createElement(context: ExtensionContext): Element {
		return new Document();
	}

	@Override
	public get elementType(): ElementType {
		return ElementType.BLOCK;
	}

	@Override
	public get endMarker(): ExtensionEndMarker {
		return ExtensionEndMarker.NONE;
	}
}

export public class ParagraphHandler extends AbstractExtension {

	@Override
	public get name(): string {
		return "p";
	}

	@Override
	public createElement(context: ExtensionContext): Element {
		return new Paragraph("p", context.indentLevel, context.currentElement);
	}

	@Override
	public get elementType(): ElementType {
		return ElementType.PAR;
	}

	@Override
	public get endMarker(): ExtensionEndMarker {
		return ExtensionEndMarker.NONE;
	}
}

export public class PreformattedHandler extends AbstractExtension {

	@Override
	public get name(): string {
		return "pre";
	}

	@Override
	public createElement(context: ExtensionContext): Element {
		return new Paragraph("pre", context.indentLevel, context.currentElement);
	}

	@Override
	public get elementType(): ElementType {
		return ElementType.PAR;
	}

	@Override
	public get endMarker(): ExtensionEndMarker {
		return ExtensionEndMarker.NONE;
	}
}
