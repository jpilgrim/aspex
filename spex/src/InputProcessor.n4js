import {CatcodeMap} from "Category";
import {DefaultExtensions} from "DefaultExtensions";
import {Extension} from "Extension";
import {Element} from "Nodes";

export public interface ~ActiveExtension<T extends Element> {
	extension: Extension;
	element?: T;
}

export public class ProcessorState {

	@Final
	catcodeMap = new CatcodeMap();

	@Final
	blockNameExtensions = new Map<string, Extension>();

	@Final
	blockCtrlExtensions = new Map<string, [Extension]>();

	@Final
	inlineNameExtensions = new Map<string, Extension>();

	@Final
	inlineCtrlExtensions = new Map<string, [Extension]>();

	@Final
	activeExtensions: [ActiveExtension<Element>] = [];

	public addExtensions(extensions: [Extension]) {
		for (let ext of extensions) {
			if (ext.block) {
				if (ext.refByName) {
					this.blockNameExtensions.set(ext.name, ext);
				}
				if (ext.ctrlStart) {
					let extsWithStart = this.blockCtrlExtensions.get(ext.ctrlStart);
					if (extsWithStart) {
						if (extsWithStart.find(other => other.name == ext.name)) {
							throw new Error("Duplicate control block extension " + ext.name + ".");
						}
					} else {
						extsWithStart = [];
						this.blockCtrlExtensions.set(ext.ctrlStart, extsWithStart);
					}
					extsWithStart.push(ext);
				}
			} else { // inline
				if (ext.refByName) {
					this.inlineNameExtensions.set(ext.name, ext);
				}
				if (ext.ctrlStart) {
					let extsWithStart = this.inlineCtrlExtensions.get(ext.ctrlStart);
					if (extsWithStart) {
						if (extsWithStart.find(other => other.name == ext.name)) {
							throw new Error("Duplicate control inline extension " + ext.name + ".");
						}
					} else {
						extsWithStart = [];
						this.inlineCtrlExtensions.set(ext.ctrlStart, extsWithStart);
					}
					extsWithStart.push(ext);
				}
			}
		}
	}
	
	get activeExtension(): ActiveExtension<Element> {
		return this.activeExtensions[this.activeExtensions.length-1]
	}

	get activeInlineExtension(): ActiveExtension<Element> {
		let active = this.activeExtension;
		if (active.extension.block) {
			return undefined;
		}
		return active;
	}
	
}

export public class DefaultProcessorState extends ProcessorState {
	
	constructor() {
		this.addExtensions(new DefaultExtensions().extensions);
	}
}

export public class InputProcessor {

	@Inject 
	protected processorState: ProcessorState;
	

}
