import {CatcodeMap} from "Category";
import {DefaultExtensions} from "DefaultExtensions";
import {Extension} from "Extension";
import {Element} from "Nodes";
import {ElementType} from "Nodes";

export public interface ~ActiveExtension<T extends Element> {
	extension: Extension;
	element?: T;
}

export public class ProcessorState {

	@Final
	catcodeMap = new CatcodeMap();

	@Final
	nameBlockOrParExtensions = new Map<string, Extension>();

	@Final
	ctrlBlockOrParExtensions = new Map<string, [Extension]>();

	@Final
	nameInlineExtensions = new Map<string, Extension>();

	@Final
	ctrlInlineExtensions = new Map<string, [Extension]>();

	@Final
	activeExtensions: [ActiveExtension<Element>] = [];

	public addExtensions(extensions: [Extension]) {
		for (let ext of extensions) {
			if (ext.elementType != ElementType.INLINE) {
				if (ext.refByName) {
					this.nameBlockOrParExtensions.set(ext.name, ext);
				}
				if (ext.ctrlStart) {
					let extsWithStart = this.ctrlBlockOrParExtensions.get(ext.ctrlStart);
					if (extsWithStart) {
						if (extsWithStart.find(other => other.name == ext.name)) {
							throw new Error("Duplicate control block extension " + ext.name + ".");
						}
					} else {
						extsWithStart = [];
						this.ctrlBlockOrParExtensions.set(ext.ctrlStart, extsWithStart);
					}
					extsWithStart.push(ext);
				}
			} else { // inline
				if (ext.refByName) {
					this.nameInlineExtensions.set(ext.name, ext);
				}
				if (ext.ctrlStart) {
					let extsWithStart = this.ctrlInlineExtensions.get(ext.ctrlStart);
					if (extsWithStart) {
						if (extsWithStart.find(other => other.name == ext.name)) {
							throw new Error("Duplicate control inline extension " + ext.name + ".");
						}
					} else {
						extsWithStart = [];
						this.ctrlInlineExtensions.set(ext.ctrlStart, extsWithStart);
					}
					extsWithStart.push(ext);
				}
			}
		}
	}
	
	get activeExtension(): ActiveExtension<Element> {
		return this.activeExtensions ? this.activeExtensions[this.activeExtensions.length-1] : undefined;
	}

	get activeInlineExtension(): ActiveExtension<Element> {
		let active = this.activeExtension;
		if (active && active.extension.elementType != ElementType.INLINE) {
			return undefined;
		}
		return active;
	}
	
}

export public class DefaultProcessorState extends ProcessorState {
	
	constructor() {
		this.addExtensions(new DefaultExtensions().extensions);
	}
}

export public class InputProcessor {

	protected processorState: ProcessorState;

}
