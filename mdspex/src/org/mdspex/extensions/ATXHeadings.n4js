import {Element} from "org/mdspex/ASTNodes";
import {Paragraph} from "org/mdspex/ASTNodes";
import {Category} from "org/mdspex/Category";
import {ElementAnchorWithScope} from "org/mdspex/ElementAnchor";
import {AbstractExtension} from "org/mdspex/Extension";
import {ExtensionContext} from "org/mdspex/Extension";
import {ExtensionEndMarker} from "org/mdspex/Extension";
import {ExtensionType} from "org/mdspex/Extension";
import {IdentityProvider} from "org/mdspex/Extension";
import {OutputProvider} from "org/mdspex/Extension";

class Heading extends Paragraph {
	level: int;
}


export public class ATXHeading extends AbstractExtension {
	
	const ATXStartRegEx = /^#{1,6}\s/
	const ATXEndRegEx = /^#+\s*$/
	const HeadingProvider = new IdentityProvider("h1", "h2", "h3", "h4", "h5", "h6");

	@Override
	public get ctrlStart(): string {
		return "#"
	}

	@Override
	public get ctrlEnd(): string {
		return "#"
	}
	
	@Override
	public get extensionType(): ExtensionType {
		return ExtensionType.PAR
	}

	@Override
	public get endMarker(): ExtensionEndMarker {
		return ExtensionEndMarker.EOL;
	}
	
	@Override
	public get name(): string {
		return "ATXHeading"
	}

	/**
	 * Returns level of heading (1-6).
	 */
	@Override
	public matchStart(context: ExtensionContext): int {
		if (context.indentLevel>0) {
			return 0;
		}
		let length = this.findMatch(context.restOfLineWithCtrl, ATXHeading.ATXStartRegEx);
		return length -1;
	}
	
	@Override
	public matchEnd(context: ExtensionContext): int {
		if (context.previousRawToken.category!=Category.SPACE) {
			return 0;
		}
		return this.findMatch(context.restOfLineWithCtrl, ATXHeading.ATXEndRegEx);
	}
	
	findMatch(line: string, re: RegExp): int	{
		let res = line.match(re);
		// [ '###### ', index: 0, input: '###### Hello' ]
		if (res) {
			return res[0].length;
		}
		return 0;
	}
	
	@Override
	public createElement(context: ExtensionContext): Element {
		let level = context.processorState.currentToken.rawValue.length;
		let heading = new Heading("h" + level, context.indentLevel, context.currentElement);
		heading.level = level;
		return heading;
	}
	
	@Override
	public closeElement(element: Element, context: ExtensionContext) {
		super.closeElement(element, context);
		
		if(!element instanceof Heading) {
			throw new Error("Internal state broken, expected heading to be closed, was " + element.constructor );
		}
		
		let level = (element as Heading).level;
		let containingScope = this.findContainingScope(context.processorState.currentScope, level-1);
		element.setAnchor("sec", element.text, containingScope, true);
		context.processorState.currentScope = element.anchor as ElementAnchorWithScope;
	}
	
	private findContainingScope(currentScope: ElementAnchorWithScope, requestedLevel: int): ElementAnchorWithScope {
		let s = currentScope;
		while (s) {
			if (s.element instanceof Heading) {
				let foundLevel = (s.element as Heading).level;
				if (foundLevel<=requestedLevel) return s;
			} 
			s = s.containingScope;
		}
		return s; // might be undefined (h1)
	}
	
	@Override
	public get outputProvider(): OutputProvider {
		return ATXHeading.HeadingProvider 
	}
	
	
}
