import {N4Injector} from "n4js/lang/N4Injector";
import {Block} from "org/mdspex/ASTNodes";
import {CDATAContainer} from "org/mdspex/ASTNodes";
import {Document} from "org/mdspex/ASTNodes";
import {Category} from "org/mdspex/Category";
import {Extension} from "org/mdspex/Extension";
import {ExtensionEndMarker} from "org/mdspex/Extension";
import {ExtensionType} from "org/mdspex/Extension";
import {InputSource} from "org/mdspex/InputSource";
import {Processor} from "org/mdspex/Processor";
import {ActiveExtension} from "org/mdspex/ProcessorState";
import {ProcessorState} from "org/mdspex/ProcessorState";
import {DocumentHandler} from "org/mdspex/extensions/DefaultExtensions";
import {ParagraphHandler} from "org/mdspex/extensions/DefaultExtensions";
import {PreformattedHandler} from "org/mdspex/extensions/DefaultExtensions";
import {Lexer} from "org/mdspex/parser/Lexer";
import {Token} from "org/mdspex/parser/Token";

function last(s: string): string {
	if (s) {
		return s.charAt(s.length - 1);
	}
	return "";
}

function <T>peek(array: [T]): T {
	if (array) {
		return array[array.length - 1];
	}
	return undefined;
}

/**
 * Parses an input source (InputSource) and produces the AST (root: Document).
 * 
 * The parser uses the extensions to create elements.
 * These extensions are provided by the ProcessorState.
 * Additionally, three handlers are used to create elements:
 * 1. ParagraphHandler 
 * 2. PreformattedHandler
 * 3. DocumentHandler.
 * (see fields for details)
 */
export public class Parser extends Processor {

	@Inject
	lexer: Lexer;

	/**
	 * This is the default if no other block extension is found
	 * and the block is not indented to become a preformatted block.
	 */
	@Inject
	paragraphHandler: ParagraphHandler;

	/**
	 * Used if a block has an extra indent but not specific block
 	 * extension is found.
	 */
	@Inject
	preformattedHandler: PreformattedHandler;

	/** 
	 * Used for root element.
	 */
	@Inject
	documentHandler: DocumentHandler;
	
	eolCount: int = 0;

	@Inject
	injector: N4Injector;
	// workaround because @PerInjectionSingleton not implemented!
	
	/**
	 * Called by the main application (e.g. CLI) class to parse the input.
	 */
	parse(inputSource: InputSource): Document {
		this.init(this.injector.create(ProcessorState));

		this.processorState.outputProviders.set(this.paragraphHandler.name, this.paragraphHandler.outputProvider);
		this.processorState.outputProviders.set(this.preformattedHandler.name, this.preformattedHandler.outputProvider);

		this.lexer.init(this.processorState);
		this.processorState.setInputSource(inputSource);

		let tokenEntry: IteratorEntry<Token>;
		this.createElement(this.documentHandler);
		let document = this.processorState.activeExtension.element as Document;
		
		// Init parser
		this.processorState.indentLevel = 0;
		this.eolCount = 0;

		// Do parse
		while (!(tokenEntry = this.lexer.next()).done) {
			let token = tokenEntry.value;

			switch (token.category) {
				case Category.EOL:
					this.closeWordElement();
					this.closeLineElement();

					this.eolCount++;
					if (this.eolCount == 2) { // end current paragraph
						this.popToBlock(this.processorState.activeExtension.element.indentLevel);
					}
					this.processorState.indentLevel = 0;
					break;
				case Category.INDENT:
					this.processorState.indentLevel++;
					break;
				case Category.CMD: case Category.CTRL:
					let tokenExt = token.activeExtension;
					if (tokenExt.element) { // ctrl/cmd signaled end of element:
						this.closeElement();
					} else { // create new element
						if (tokenExt.extension.extensionType != ExtensionType.INLINE) {
							this.popToBlock(this.processorState.indentLevel);
						} else {
							this.ensureCDATAContainer();
						}
						this.createElement(tokenExt.extension);
					}
					this.eolCount = 0;
					break;
				case Category.SPACE:
					this.closeWordElement();
				// and continue:	
				default:
					let cdataContainer = this.ensureCDATAContainer();
					if (this.eolCount == 1 && cdataContainer.element.tailCDATA) {
						cdataContainer.element.addCDATA(" ");
					}
					cdataContainer.element.addCDATA(token.rawValue);
					this.eolCount = 0;
			}
		}
		
		// close all elements at the end
		while (this.processorState.activeExtensions.length>0) {
			this.closeElement();
		}

		return document;
	}

	closeLineElement() {
		let nested = 0;
		for (let i = this.processorState.activeExtensions.length - 1; i >= 0; i--) {
			let ext = this.processorState.activeExtensions[i];
			switch (ext.extension.extensionType) {
				case ExtensionType.BLOCK: return;
			}
			nested++;
			if (ext.extension.endMarker == ExtensionEndMarker.EOL) {
				break;
			}
		}
		for (let i = 0; i < nested; i++) {
			this.closeElement();
		}
	}

	closeWordElement() {
		let nested = 0;
		for (let i = this.processorState.activeExtensions.length - 1; i >= 0; i--) {
			let ext = this.processorState.activeExtensions[i];
			switch (ext.extension.extensionType) {
				case ExtensionType.PAR: 
				case ExtensionType.BLOCK: return;
			}
			nested++;
			if (ext.extension.endMarker == ExtensionEndMarker.SPACE) {
				break;
			}
		}
		for (let i = 0; i < nested; i++) {
			this.closeElement();
		}
	}

	/**
	 * Selects element (and extension) with given indent level.
	 * Elements with higher indent level are closed.
	 */
	popToBlock(indentLevel: int): ActiveExtension<Block> {
		while (this.processorState.activeExtensions) {
			let activeExt = peek(this.processorState.activeExtensions);
			if (activeExt.element instanceof Block
				&& activeExt.element.indentLevel <= indentLevel) {
				return activeExt as ActiveExtension<Block>;
			}
			this.closeElement();
		}
		throw new Error("Document missing");
	}

	createElement(extension: Extension) {
		let element = extension.createElement(this.processorState.createExtensionContext());
		let activeExt = {
				extension: extension,
				element: element
			};
		this.processorState.activeExtensions.push(activeExt);
		if (element instanceof Block) {
			this.processorState.indentLevel = element.indentLevel;
		}
	}

	closeElement() {
		let {extension, element} = this.processorState.activeExtensions.pop();
		extension.closeElement(element, this.processorState.createExtensionContext());
	}
	
	/**
	 * Ensures that a CDATAContainer is available at the correct indent level.
	 */
	ensureCDATAContainer(): ActiveExtension<CDATAContainer> {

		if (this.processorState.activeExtension.element.indentLevel > this.processorState.indentLevel) {
			this.popToBlock(this.processorState.indentLevel);
		}

		if (!(this.processorState.activeExtension.element instanceof CDATAContainer)) {
			while (
				//(!this.processorState.activeExtension.element instanceof Block) ||
				this.processorState.indentLevel < this.processorState.activeExtension.element.indentLevel
			) {
				this.closeElement();
			}
			if (this.processorState.indentLevel > this.processorState.activeExtension.element.indentLevel) {
				this.createElement(this.preformattedHandler);
			} else { // this.processorState.indentLevel == this.processorState.activeExtension.element.indentLevel
				this.createElement(this.paragraphHandler);
			}
		}
		return this.processorState.activeExtension as ActiveExtension<CDATAContainer>;
	}

	private closeInlineElements() {
		while (this.processorState.activeInlineExtension) {
			this.closeElement();
		}
	}

}
