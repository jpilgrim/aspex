import {ElementAnchor} from "org/mdspex/ElementAnchor";
import {ElementAnchorWithScope} from "org/mdspex/ElementAnchor";
import {ContainedFQN} from "org/mdspex/QualifiedNames";
import {FQN} from "org/mdspex/QualifiedNames";


export public function is(node: Node, name: string): boolean {
	if (node instanceof Element) return (node as Element).name == name;
	return false;
}

export public enum ElementType {
	BLOCK,
	PAR,
	INLINE,
	/**
	 * "Character Formatting", 
	 * almost similar to inline, except that it its content does not necessarily
	 * define a "word".
	 */
	CFORMATTING,
	/**
	 * Character Data, returned only by CDATA.
	 */
	CDATA
}

/**
 * [SPEX-1005]
 */
export public function normalizeSegment(seg: string): string {
	let s = "";
	let lastChar = "";
	for (let i = 0; i < seg.length; i++) {
		let c = seg.charAt(i);
		let code = seg.charCodeAt(i);
		if (code > 31) { // skip control
			if ( // replace ASCII space, punctuation and symbols
					(code >= 32 && code <= 47)
				|| (code >= 58 && code <= 64)
				|| (code >= 91 && code <= 96)
				|| (code >= 123 && code <= 126)
				|| (code >= 160 && code <= 191) // Latin space, punctuation and symbols
				) {
				c = "_";
			}
			if (c != '_')
			{
				if (lastChar == '_' && s) {
					s += '_';
				}
				s += c;
			}
			lastChar = c;
		}
	}
	return s;
}

export public interface ASTSwitch<T> {

	switch(node: Node): T {
		if (!node) {
			return undefined;
		}
		if (node instanceof Document) {
			return this.caseDocument(node as Document);
		}
		if (node instanceof Block) {
			return this.caseBlock(node as Block);
		}
		if (node instanceof Inline) {
			return this.caseInline(node as Inline);
		}
		if (node instanceof Paragraph) {
			return this.caseParagraph(node as Paragraph);
		}
		if (node instanceof CDATAContainer) {
			return this.caseCDATAContainer(node as CDATAContainer);
		}
		if (node instanceof CDATA) {
			return this.caseCDATA(node as CDATA);
		}
		if (node instanceof Element) {
			return this.caseElement(node as Element);
		}
		return this.caseNode(node);

	}

	protected caseNode(node: Node): T {
		return this.defaultCase(node);
	}
	protected caseElement(node: Element): T {
		return this.caseNode(node);
	}
	protected caseBlock(node: Block): T {
		return this.caseElement(node);
	}
	protected caseCDATAContainer(node: CDATAContainer): T {
		return this.caseElement(node);
	}
	protected caseInline(node: Inline): T {
		return this.caseCDATAContainer(node);
	}
	protected caseParagraph(node: Paragraph): T {
		return this.caseCDATAContainer(node);
	}
	protected caseCDATA(node: CDATA): T {
		return this.defaultCase(node);
	}
	protected caseAttribute(node: Attribute): T {
		return this.defaultCase(node);
	}
	protected caseDocument(node: Document): T {
		return this.caseBlock(node);
	}

	protected defaultCase(node: Node | Attribute): T {
		return undefined;
	}
}

export public abstract class Node {

	@Final
	public parent: Element;

	startOffset: int;
	endOffset: int;
	
	abstract get type(): ElementType

	/**
	 * Creates this node with given parent and add this node to parent's child nodes.
	 */
	constructor(parent: Element) {
		if (this instanceof Document) {
			return;
		}

		if (!parent) {
			throw new Error("node requires a parent");
		}

		this.parent = parent;
		if (!parent.nodes) {
			parent.nodes = [this];
		} else {
			parent.nodes.push(this);
		}

	}

	/**
	 * Returns XML-like string of this node and its children, formatting (indentation wise) according
	 * to indent level. Basically used for debugging and tests.
	 */
	public abstract toXML(indent=0): string
	
	
	public abstract get text(): string
	
	public get document(): Document {
		if (this.parent)
			return this.parent.document;
		return undefined;
	}

}

const TAB = "    ";

export public abstract class Element extends Node {

	/**
	 * Name of the element, e.g. "<br />" woud have the name "br". This is not
	 * the attribute "name".
	 */
	@Final
	name: string;

	@Final
	indentLevel: int;
	
	@Final
	id: string

	/**
	 * Only set if this element has an name and can be linked to, 
	 * i.e. it is an anchor.
	 */
	anchor: ElementAnchor;

	attributes: [Attribute];
	
	nodes: [Node];

	constructor(name: string, indentLevel: int, parent: Element) {
		super(parent);
		this.name = name;
		this.indentLevel = indentLevel;
		if (parent) {
			this.id = parent.document.nextID;
		}
	}
	
	get hasNodes(): boolean {
		return this.nodes && this.nodes.length>0 ? true : false;
	}
	
	/**
	 * Sets the anchor of the element. This can often be done only
	 * when the element is to be closed (by the parse), since the
	 * information required to compute the name may not be present earlier.
	 */
	setAnchor(type: string, simpleName: string, containingScope: ElementAnchorWithScope, definesScopeItself=false) {
		let ctor: constructor{ElementAnchor} = (definesScopeItself ? ElementAnchorWithScope : ElementAnchor);
		this.anchor = new ctor({element: this, name: simpleName, type: type, containingScope: containingScope});
	}

	get fqn(): ContainedFQN {

		if (this.anchor) {
			return this.anchor.fqn;
		}
		return undefined;
	}

	@Override
	public toXML(): string {
		let parts: [string] = [];
		parts.push("<" + this.name + (this.attributes ?
				this.attributes.map(a => " " + a.name + '= "' + a.value + '"').join("") : ""));
		
		if (this.id && this.anchor) { // only printout id for anchored elements
			parts.push(' id="' + this.id+'"');
		}
		
		if (this.hasNodes) {
			parts.push(">");
			parts.push(this.nodes.map((c, i) => {
					if (!(c instanceof CDATA) || i > 0) {
						if (c instanceof Element) {
							let ce = c as Element;
							return "\n" /*  + ce.indentLevel + ":" */ + TAB.repeat(ce.indentLevel) + c.toXML();
						} else {
							return "\n" + TAB.repeat(this.indentLevel) + c.toXML();
						}
					} else {
						return c.toXML();
					}
				}).join(""));
			if (!(this.nodes[this.nodes.length - 1] instanceof CDATA)) {
				parts.push("\n" + TAB.repeat(this.indentLevel));
			}
			parts.push("</" + this.name + ">");
		} else {
			parts.push(" />");
		}
		return parts.join("");
	}

	/**
	 * Returns the closest block element, either itself or container.
	 */
	public get block(): Block {
		if (this.parent) return this.parent.block;
		return undefined;
	}

	public get lastChild(): Node {
		if (this.hasNodes) {
			return this.nodes[this.nodes.length - 1];
		}
		return undefined;
	}

	public trim() {
		if (! this.hasNodes) return;
		let firstChild = this.nodes[0]; 
		let lastChild = this.lastChild;
		if (lastChild instanceof CDATA) {
			if (lastChild=firstChild) {
				(lastChild as CDATA).trim();
				return;
			}
			(lastChild as CDATA).trim(false, true);
		}
		if (lastChild instanceof CDATA) {
			(lastChild as CDATA).trim(true, false);
		}
	}

	public setAttribute(name: string, value: string) {
		let attr = this.attributes.find(a => a.name == name);
		if (attr) {
			attr.value = value;
		} else {
			attr = new Attribute(name, value);
			this.attributes.push(attr);
		}
	}

	public getAttribute(name: string, defValue: string=): string {
		let attr = this.attributes.find(a => a.name == name);
		if (attr) {
			return attr.value;
		}
		return defValue;
	}
	
	@Override
	public get text(): string {
		if (!this.hasNodes) return "";
		let t = "";
		for (let c of this.nodes) {
			if (c.text && t && !t.endsWith(" ") && c.type!=ElementType.CFORMATTING) {
				t+=" ";
			}
			t += c.text;
			
		}
		return t;
	}
	
}

/**
 * A block contains other elements but no CDATA directly.
 */
export public class Block extends Element {

	/**
	 * Returns this.
	 */
	@Override
	public get block(): Block {
		return this;
	}

	@Override
	public get type(): ElementType {
		return ElementType.BLOCK;
	}
}

export public abstract class CDATAContainer extends Element {

	public get tailCDATA(): string {
		if (this.nodes && this.nodes[this.nodes.length - 1] instanceof CDATA) {
			let cdata = this.nodes[this.nodes.length - 1] as CDATA;
			return cdata.content;
		}
		return "";
	}

	public addCDATA(s: string) {
		let cdata: CDATA;
		if (this.nodes && this.nodes[this.nodes.length - 1] instanceof CDATA) {
			cdata = this.nodes[this.nodes.length - 1] as CDATA;
		} else {
			cdata = new CDATA(this);
		}
		cdata.add(s);
	}

}

/** 
 * An inline element may contain CDATA, other inline or CFORMATTING elements, 
 * but not blocks, paragraphs or lines.
 */
export public class Inline extends CDATAContainer {

	@Override
	public get type(): ElementType {
		return ElementType.INLINE;
	}
}

/** 
 * A character formatting element may contain CDATA or other CFORMATTING elements, 
 * but not blocks, paragraphs, inline or lines.
 */
export public class CFormatting extends CDATAContainer {

	@Override
	public get type(): ElementType {
		return ElementType.CFORMATTING;
	}
}

export public class Link extends Inline {

	constructor(indentLevel: int, parent: Element, targetPQN: string) {
		super("link", indentLevel, parent);
		this.setAttribute("pqn", targetPQN);
	}

	public resolve(fqn: FQN) {
		this.setAttribute("fqn", fqn.toString());
	}
}

/**
 * A paragraph can only contain CDATA or inline elements, but no block elements nor
 * other paragraphs. 
 */
export public class Paragraph extends CDATAContainer {

	@Override
	public get type(): ElementType {
		return ElementType.PAR;
	}
}

@Final
export public class CDATA extends Node {
	content = "";

	@Override
	public toXML(): string {
		return this.content;
	}

	public add(s: string) {
		this.content = this.content + s;
	}

	public trim(front=true,tail=true) {
		if (front&&tail) {
			this.content = this.content.trim();
			return;
		}
		let f=0;
		if (front) {
			while (f<this.content.length && this.content.charAt(f)==" ") {
				f++;
			}
		}
		let t=this.content.length;
		if (tail) {
			while (t>0 && this.content.charAt(t)==" ") {
				t--;
			}
		}
		this.content = this.content.substring(f, t);
	}
	
	@Override
	public get text(): string {
		return this.content;
	}

	@Override
	public get type(): ElementType {
		return ElementType.CDATA;
	}

}

@Final
export public class Attribute {

	@Final
	name: string;
	value: string;

	public constructor(name: string, value: string) {
		this.name = name;
		this.value = value;
	}
}

@Final
export public class Document extends Block {
	
	idcounter = 256;
	
	/**
	 * 
	 */
	indexes: Map<string, [Element]>;

	constructor() {
		super("spex", 0, undefined);
	}

	public stringify(offsets=false, ids=false): string {
		return JSON.stringify(this, (key, value) => {
				if (key == "parent" || key == "indentLevel"
					|| (!offsets && key.endsWith("Offset"))
					|| (!ids && key == "id")) {
					return undefined;
				}
				return value;
			});
	}

	/**
	 * Increases the id counter and returns it as a hex string.
	 */	
	public get nextID(): string {
		this.idcounter++
		return this.idcounter.toString(16);
	}
	
	@Override
	public get document(): Document {
		return this;
	}

}
