import {Element} from "org/mdspex/ASTNodes";
import {FQN} from "org/mdspex/QualifiedNames";
import {PQN} from "org/mdspex/QualifiedNames";
import {QualifiedName} from "org/mdspex/QualifiedNames";
import {matchSegment} from "org/mdspex/QualifiedNames";

export public interface Anchor {
	/**
	 * Returns the type of the anchor.
	 */
	get type(): string

	/**
	 * Returns the id of the anchor.
	 */
	get id(): string;

	get fqn(): FQN;
}

export public interface IDScope {

	/** The elements of that scope. */
	get scopedAnchors(): [? extends Anchor]

	/**
	 * The containing (parent) scope, may be undefined if no parent scope is defined. 
	 */
	get containingScope(): IDScope;
	
	get topLevel(): boolean {
		return ! this.containingScope;
	}

	/**
	 * Returns the id of the element defining the scope.
	 */
	get id(): string;

	find(pid: PQN, firstOnly=false): [? extends Anchor] {
		let candidates = firstOnly ?
			[this.scopedAnchors.find(eq => {
				return matchSegment(eq.id, pid.lastSegment) && (!pid.type || eq.type == pid.type);
			})] :
			this.scopedAnchors.filter(eq => {
				return matchSegment(eq.id, pid.lastSegment) && (!pid.type || eq.type == pid.type);
			});
		if (candidates.length > 0) {
			let scope: IDScope = this;
			for (let seg of pid.reversedSegmentsWithoutLast) {
				scope = scope.containingScope;
				if (!scope || scope.id != seg) {
					return [];
				}
			}
		}
		return candidates;
	}

}

/**
 * This is the basic data structure for the global index.
 * It stores the anchors with reversed FQNs whereby the FQN is not stored explicitly.
 * 
 * Given three fqns "a.b.c", "x.y.c", and "a.b.e". This would create the following 
 * map structure (in JSON style with the map as properties):
 * 
 * 	c: { anchor: undefined
 * 		 predecessors: {
 * 			b: { anchor: undefined
 * 				 predecessors: {
 * 					a: { anchor: a.b.c, parents: undefined }
 * 				 }},
 * 			y: { anchor: undefined
 * 				 predecessors: {
 * 					x: { anchor: x.y.c, parents: undefined }
 * 		}}}},
 * 	e: { anchor: undefined
 * 		 predecessors: {
 * 			b: { anchor: undefined
 * 				 predecessor: {
 * 					a: { anchor: a.b.e, parents: undefined }
 * 		}}}} 
 * 
 * This enables very fast look-up using PQNs. E.g. "c" would return "a.b.c" and "x.y.c"
 * and this would require only to lookup "c" and then transitively collect all
 * anchors beneath it without further evaluation of any segments.
 *  
 */
export public class SegmentMap {
	/**
	 * The predecessor segments. Since the tree is "reversed", the SegmentMaps contained
	 * as values in this map actually represent the "preceeding" segments of the
	 * qualified ID.
	 */
	private predecessors = new Map<string, SegmentMap>();
	
	/**
	 * Optionally an anchor, this would be always set if parents is empty.
	 * Note that the last segment of the anchor is not stored in this
	 * map itself but rather by its containing map.
	 */
	anchor: Anchor;

	getOrCreatePredecessor(segment: string): SegmentMap {
		let predecessor = this.predecessors.get(segment);
		if (!predecessor) {
			predecessor = new SegmentMap();
			this.predecessors.set(segment, predecessor);
		}
		return predecessor;
	}

	/**
	 * Collects all anchors matching given pqn represented by reversedSegments iterator.
	 * Returns true if an anchor has been found and if firstOnly is set to true.
	 * This methods is only used by MDSpexIndex.find
	 */
	collectAnchors(reversedSegments: Iterator<string>, anchors: [Anchor], firstOnly=true): boolean {
		let seg = reversedSegments.next();
		if (seg.done) {
			if (this.anchor) {
				anchors.push(this.anchor);
				if (firstOnly) return true;
			}
			for (let p of this.predecessors.values()) {
				if (p.collectAnchors(reversedSegments, anchors) && firstOnly) {
					return true;
				}
			}
		} else {
			// quick
			let p = this.predecessors.get(seg.value);
			if (p) {
				return p.collectAnchors(reversedSegments, anchors);
			}
			if (QualifiedName.containsWildcard(seg.value)) {
				for (let [name, map] of this.predecessors.entries()) {
					if (matchSegment(name, seg.value)) {
						if (map.collectAnchors(reversedSegments, anchors) && firstOnly) {
							return true;
						}
					}
				}
			}
		}
		return false;
	}

}

export public class MDSpexIndex {
	
	/**
	 * This is the global index to enable fast retrieval of anchors based on
	 * PQNs. This initial map uses the type as key. For the functionality of
	 * the index, see SegmentMap.
	 */
	inversedFQNsByType = new Map<string, SegmentMap>();
	
	/**
	 * Adds given anchor to index, so that it is retrievable via a
	 * PQN.
	 * 
	 * Returns the anchor previously registered for the anchor's FQN or undefined,
	 * if no such anchor exists (which should usually be the case).
	 */
	add(anchor: Anchor): Anchor {
		let segmap = this.inversedFQNsByType.get(anchor.type);
		if (!segmap) {
			segmap = new SegmentMap();
			this.inversedFQNsByType.set(anchor.type, segmap);
		}
		for (let seg of anchor.fqn.reversedSegments) {
			segmap = segmap.getOrCreatePredecessor(seg);
		}
		let old = segmap.anchor;
		segmap.anchor = anchor;
		return old;
	}

	/**
	 * Finds an anchor by given pqn. If context is not given, then only a global
	 * search is performed.
	 * 
	 * Local anchors always shadow global anchors.
	 * 
	 * [SPEX-1004]
	 */
	public find(pqn: PQN, context: Element = undefined, firstOnly=false): [? extends Anchor] {

		// local
		if (context && context.anchor) {
			let anchors = context.anchor.containingScope.find(pqn, firstOnly);
			if (anchors.length > 0) {
				return anchors;
			}
		}

		// global
		let anchors: [Anchor] = [];
		if (pqn.type) {
			let segMap = this.inversedFQNsByType.get(pqn.type);
			if (segMap) {
				segMap.collectAnchors(pqn.reversedSegments[Symbol.iterator](), anchors, firstOnly);
			}
		} else {
			for (let segMap of this.inversedFQNsByType.values()) {
				segMap.collectAnchors(pqn.reversedSegments[Symbol.iterator](), anchors, firstOnly);
				if (firstOnly && anchors.length > 0) break;
			}
		}
		return anchors;
	}

}
