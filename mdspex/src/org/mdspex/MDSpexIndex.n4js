import {Element} from "org/mdspex/ASTNodes";
import {PQID} from "org/mdspex/IDs";
import {FQID} from "org/mdspex/IDs";
import {QID} from "org/mdspex/IDs";
import {matchSegment} from "org/mdspex/IDs";

export public interface Anchor {
	/**
	 * Returns the type of the anchor.
	 */
	get type(): string

	/**
	 * Returns the id of the anchor.
	 */
	get id(): string;

	get fqid(): FQID;
}

export public interface IDScope {

	/** The elements of that scope. */
	get scopedAnchors(): [? extends Anchor]

	/**
	 * The parent scope, may be undefined if no parent scope is defined. 
	 */
	get parentScope(): IDScope;

	/**
	 * Returns the id of the element defining the scope.
	 */
	get id(): string;

	find(pid: PQID, firstOnly=false): [? extends Anchor] {
		let candidates = firstOnly ?
			[this.scopedAnchors.find(eq => {
				return matchSegment(eq.id, pid.lastSegment) && (!pid.type || eq.type == pid.type);
			})] :
			this.scopedAnchors.filter(eq => {
				return matchSegment(eq.id, pid.lastSegment) && (!pid.type || eq.type == pid.type);
			});
		if (candidates.length > 0) {
			let scope: IDScope = this;
			for (let seg of pid.reversedSegmentsWithoutLast) {
				scope = scope.parentScope;
				if (!scope || scope.id != seg) {
					return [];
				}
			}
		}
		return candidates;
	}

}

export public class SegmentMap {
	parents = new Map<string, SegmentMap>();
	anchor: Anchor;

	getOrCreateParent(segment: string): SegmentMap {
		let parent = this.parents.get(segment);
		if (!parent) {
			parent = new SegmentMap();
			this.parents.set(segment, parent);
		}
		return parent;
	}

	/**
	 * Collects all anchors matching given pqid represented by reversedSegments iterator.
	 * Returns true if an anchor has been found and if firstOnly is set to true.
	 * This methods is only used by MDSpexIndex.find
	 */
	collectAnchors(reversedSegments: Iterator<string>, anchors: [Anchor], firstOnly=true): boolean {
		let seg = reversedSegments.next();
		if (seg.done) {
			if (this.anchor) {
				anchors.push(this.anchor);
				if (firstOnly) return true;
			}
			for (let p of this.parents.values()) {
				if (p.collectAnchors(reversedSegments, anchors) && firstOnly) {
					return true;
				}
			}
		} else {
			// quick
			let p = this.parents.get(seg.value);
			if (p) {
				return p.collectAnchors(reversedSegments, anchors);
			}
			if (QID.containsWildcard(seg.value)) {
				for (let [name, map] of this.parents.entries()) {
					if (matchSegment(name, seg.value)) {
						if (map.collectAnchors(reversedSegments, anchors) && firstOnly) {
							return true;
						}
					}
				}
			}
		}
		return false;
	}

}

export public class MDSpexIndex {

	inversedFQIDsByType = new Map<string, SegmentMap>();

	add(anchor: Anchor) {
		let segmap = this.inversedFQIDsByType.get(anchor.type);
		if (!segmap) {
			segmap = new SegmentMap();
			this.inversedFQIDsByType.set(anchor.type, segmap);
		}
		for (let seg of anchor.fqid.reversedSegments) {
			segmap = segmap.getOrCreateParent(seg);
		}
		// TODO warning
		segmap.anchor = anchor;
	}

	public find(pqid: PQID, context: Element = undefined, firstOnly=false): [? extends Anchor] {

		// local
		if (context && context.anchor) {
			let anchors = context.anchor.idscope.find(pqid, firstOnly);
			if (anchors.length > 0) {
				return anchors;
			}
		}

		// global
		let anchors: [Anchor] = [];
		if (pqid.type) {
			let segMap = this.inversedFQIDsByType.get(pqid.type);
			if (segMap) {
				segMap.collectAnchors(pqid.reversedSegments[Symbol.iterator](), anchors, firstOnly);
			}
		} else {
			for (let segMap of this.inversedFQIDsByType.values()) {
				segMap.collectAnchors(pqid.reversedSegments[Symbol.iterator](), anchors, firstOnly);
				if (firstOnly && anchors.length > 0) break;
			}
		}
		return anchors;
	}

}
