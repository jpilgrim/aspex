import {Assert} from "n4/mangel/assert/Assert";
import {FQN} from "org/mdspex/QualifiedNames";
import {PQN} from "org/mdspex/QualifiedNames";

export public class QualifiedNamesParseStringTest {

	@Parameter
    public fqnAsString: string

	@Parameters("[{index}] {0}")
    public static getFqidsAsString() {
        return ["test:a", "test:a.b.c",
        	"src:org.mdspex.FQN_parseString_Tests",
        	"bib:Gamma96a",
        	"sec:Section_1.Section_1_1.Section_1_1_a",
        	"eq:Section_1.Section_1_1.1"
        ].map(s=>[s]);
    }
    
	@Test
	testParseStringFQN() {
		let fqn = FQN.parseString(this.fqnAsString);
		let s = fqn.toString();
		Assert.equal(s, this.fqnAsString);	
	}

}

export public class PQN_parseString_Tests {

	@Parameter
    public pqnAsString: string

	@Parameters("[{index}] {0}")
    public static getPqidsAsString() {
        return ["test:a", "test:a.b.c",
        	"src:org.mdspex.FQN_parseString_Tests",
        	"bib:Gamma96a",
        	"sec:Section_1.Section_1_1.Section_1_1_a",
        	"eq:Section_1.Section_1_1.1",
        	//
        	"a", "a.b.c", "bib:he…", "type:x.….y", "…y", "y…", "….x"
        ].map(s=>[s]);
    }
    
	@Test
	testParseStringPQN() {
		try {
			let pqn = PQN.parseString(this.pqnAsString);
			var s = pqn.toString();
		} catch (e) {
			Assert.fail("Error processing " + this.pqnAsString + ": " + e);
		}
		Assert.equal(s, this.pqnAsString);	
	}

}
