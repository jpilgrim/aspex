import {FQN} from "org/mdspex/QualifiedNames";
import {PQN} from "org/mdspex/QualifiedNames";
import {Anchor} from "org/mdspex/MDSpexIndex";
import {MDSpexIndex} from "org/mdspex/MDSpexIndex";
import {Assert} from "n4/mangel/assert/Assert";
import {SegmentMap} from "org/mdspex/MDSpexIndex";

function ta(fqn: string): Anchor {
	return new TestAnchor(fqn);
}

class TestAnchor implements Anchor {

	@Override
	@Final
	public fqn: FQN;
	constructor(fqn: string) {
		this.fqn = FQN.parseString(fqn);
	}

	@Override
	public get type(): string {
		return this.fqn.type;
	}

	@Override
	public get name(): string {
		return this.fqn.lastSegment;
	}
}

export public class TestAnchorTest {

	@Test
	test() {
		let a = ta("sec:My.Main.Header");
		Assert.equal(a.name, "Header");
		Assert.equal(a.type, "sec");
		Assert.equal(a.fqn.toString(), "sec:My.Main.Header");
	}
}

export public class SegmentMapTests {

	@Test
	test() {
		let segmap = new SegmentMap();
		let parent = segmap.getOrCreatePredecessor("id");
		Assert.isNotNullOrUndefined(parent);
		Assert.equal(segmap.getOrCreatePredecessor("id"), parent);
	}

}

export public class MDSpexIndexBasicTests {

	@Test
	testSingleExactly() {
		let index = new MDSpexIndex();
		let a = ta("sec:My.Main.Header");
		index.add(a);
		Assert.equal(index.find(PQN.parseString("sec:My.Main.Header"))[0], a);
		Assert.equal(index.find(PQN.parseString("sec:My.Main.HeaderX")).length, 0);
		Assert.equal(index.find(PQN.parseString("eq:My.Main.HeaderX")).length, 0);
		Assert.equal(index.find(PQN.parseString("sec:My.Main.Header.Sub")).length, 0);
	}
}

export public class MDSpexIndexTests {
	index = new MDSpexIndex();
	a = ta("sec:My.Main.Header");
	b = ta("eq:Something.Very.Different");

	constructor() {
		this.index.add(this.a);
		this.index.add(this.b);
	}

	assertFind(pqnString: string, expect=this.a) {
		let pqn = PQN.parseString(pqnString);
		let re = this.index.find(pqn);
		Assert.equal(re.length, 1, "find(" + pqn + ") returned " + re.length + " hits, expected 1.");
		Assert.equal(re[0], expect, "wrong entry found for " + pqn);
	}

	assertFindNot(pqnString: string) {
		let pqn = PQN.parseString(pqnString);
		let re = this.index.find(pqn);
		Assert.equal(re.length, 0, "find('" + pqn + "') returned " + re.length + " hits, expected no hits.");
	}

	@Test
	testSingleExactly() {
		this.assertFind("sec:My.Main.Header");
		this.assertFind("eq:Something.Very.Different", this.b);
		this.assertFindNot("sec:My.Main.HeaderX");
		this.assertFindNot("eq:My.Main.Header");
		this.assertFindNot("sec:My.Main.Header.Sub");
	}

	@Test
	testSingleFuzzy() {
		this.assertFind("sec:My.Main.Header");
		this.assertFind("My.Main.Header");
		this.assertFind("sec:Main.Header");
		this.assertFind("sec:Header");
		this.assertFind("Header");
		this.assertFindNot("sec:My.Main");
	}

	@Test
	testSingleFuzzyWildcard() {
		this.assertFind("H…");
		this.assertFind("sec:…Header");
		this.assertFind("sec:My.M….Header");
		this.assertFind("sec:M….Header");
		this.assertFindNot("sec:My.Main.H….Sub");
		this.assertFind("sec:My.….Header");
		this.assertFind("sec:M….H…a…r");
	}

}

export public class MDSpexPerformanceTests {
	index = new MDSpexIndex();
	count = 0;

	assertFind(pqnString: string) {
		let pqn = PQN.parseString(pqnString);
		let re = this.index.find(pqn);
		Assert.equal(re.length, 1, "find(" + pqn + ") returned " + re.length + " hits, expected 1.");
	}
	
	add(fqnString: string) {
		this.index.add(ta(fqnString));
		this.count++;
	}

	/**
	 *  Chapters, Sec1 , Sec2, Sec3, Req = 111.110
	 */
	@Test
	test_100k_entries_with_one_wildcard() {
		const NUM = 10;
		this.count = 0;	
		for (let c = 1; c <= NUM; c++) {
			this.add("chapter:Chapter_" + c);
			for (let sec1 = 1; sec1 <= NUM; sec1++) {
				this.add("sec:Chapter_" + c + ".Section_+" + sec1);
				for (let sec2 = 1; sec2 <= NUM; sec2++) {
					this.add("sec:Chapter_" + c + ".Section_+" + sec1 + ".Subsection_" + sec2);
					for (let sec3 = 1; sec3 <= NUM; sec3++) {
						this.add("sec:Chapter_" + c + ".Section_+" + sec1 + ".Subsection_" + sec2 +
							".Subsubsection_" + sec3);
						for (let req = 1; req <= NUM; req++) {
							this.add("req:Chapter_" + c + ".Section_+" + sec1 + ".Subsection_" + sec2 +
								".Subsubsection_" + sec3 + ".Requirement_" + req);
						}
					}
				}
			}
		}
		for (let c = 1; c <= NUM; c++) {
			this.assertFind("chapter:Chapter_" + c);
			for (let sec1 = 1; sec1 <= NUM; sec1++) {
				this.assertFind("sec:Chapter_" + c + ".Section_+" + sec1);
				for (let sec2 = 1; sec2 <= NUM; sec2++) {
					this.assertFind("sec:Chapter_" + c + ".Section_+" + sec1 + ".Subsection_" + sec2);
					for (let sec3 = 1; sec3 <= NUM; sec3++) {
						this.assertFind("sec:Chapter_" + c + ".Section_+" + sec1 + ".Subsection_" + sec2 +
							".Subsub…" + sec3);
						for (let req = 1; req <= NUM; req++) {
							this.assertFind("Chapter_" + c + ".Section_+" + sec1 + ".Subsection_" + sec2 +
								".Subsubsection_" + sec3 + ".Requirement_" + req);
						}
					}
				}
			}
		}
		// console.log("Count: " + this.count);		
	}
}

